<!DOCTYPE html>
<html>
<meta charset="utf-8">
<style>
	p {
		margin: 0;
	}
</style>
<body>
<div id="window-property"></div>
<br>
<div id="dom-property"></div>
<br>
<div id="body-property"></div>
<br>
<div id="ele-property"></div>
<div id="ele-con-test" style="width: 50px;height: 100px;border: 10px solid red;padding: 15px;margin: 20px;overflow: scroll"></div>
</body>
<script>
	const windowProperty = document.getElementById('window-property')
	for (let i = 0; i < 4; i++) {
		windowProperty.innerHTML += '<p class="p-test"></p>'
	}
	const pTest = windowProperty.getElementsByClassName('p-test')
	function getWindowWh() {
		pTest[0].innerText = '浏览器窗口可视区宽度 去除工具条与滚动条的窗口高度与宽度 window.innerWidth:' + window.innerWidth
		pTest[1].innerText = '整个窗口的宽度 包括所有的界面元素（如工具栏/滚动）window.outerWidth:' + window.outerWidth
		pTest[2].innerText = '返回屏幕的总宽度,整个电脑屏幕的宽度 window.screen.width:' + window.screen.width
		pTest[3].innerText = '返回屏幕的宽度（不包括Windows任务栏）window.screen.availWidth:' + window.screen.availWidth
	}
	getWindowWh();

	const domProperty = document.getElementById('dom-property')
	for (let i = 0; i < 9; i++) {
		domProperty.innerHTML += '<p class="p-dom-test"></p>'
	}
	const pDomTest = domProperty.getElementsByClassName('p-dom-test')
	function getDomWh() {
		pDomTest[0].innerText = 'width + 左右padding document.documentElement.clientWidth:' + document.documentElement.clientWidth;
		pDomTest[1].innerText = 'width + 左右padding + 左右boder document.documentElement.offsetWidth:' + document.documentElement.offsetWidth;
		pDomTest[2].innerText = '获取指定标签内容层的真实宽度（可视区域宽度+被隐藏区域宽度） document.documentElement.scrollWidth:' + document.documentElement.scrollWidth;
		pDomTest[3].innerText = 'boder.top(上边框的宽度) document.documentElement.clientTop:' + document.documentElement.clientTop;
		pDomTest[4].innerText = 'boder.left(上边框的宽度) document.documentElement.clientLeft:' + document.documentElement.clientLeft;
		pDomTest[5].innerText = '当前元素 上/左边框 外边缘 到 最近的已定位父级（offsetParent） 上/左边框内边缘的距离。' +
			'如果父级都没有定位，则分别是到body 顶部 和左边的距离 document.documentElement.offsetTop:' + document.documentElement.offsetTop;
		pDomTest[6].innerText = '当前元素 上/左边框 外边缘 到 最近的已定位父级（offsetParent） 上/左边框内边缘的距离。' +
			'如果父级都没有定位，则分别是到body 顶部 和左边的距离 document.documentElement.offsetLeft:' + document.documentElement.offsetLeft;
		pDomTest[7].innerText = '内容层顶部 到 可视区域顶部的距离 document.documentElement.scrollTop:' + document.documentElement.scrollTop;
		pDomTest[8].innerText = '内容层左端 到 可视区域左端的距离. document.documentElement.scrollLeft:' + document.documentElement.scrollLeft;

	}
	getDomWh();

	const bodyProperty = document.getElementById('body-property')
	for (let i = 0; i < 9; i++) {
		bodyProperty.innerHTML += '<p class="p-body-test"></p>'
	}
	const pbodyTest = bodyProperty.getElementsByClassName('p-body-test')
	function getbodyWh() {
		pbodyTest[0].innerText = 'width + 左右padding document.body.clientWidth:' + document.body.clientWidth;
		pbodyTest[1].innerText = 'width + 左右padding + 左右boder document.body.offsetWidth:' + document.body.offsetWidth;
		pbodyTest[2].innerText = '获取指定标签内容层的真实宽度（可视区域宽度+被隐藏区域宽度） document.body.scrollWidth:' + document.body.scrollWidth;
		pbodyTest[3].innerText = 'boder.top(上边框的宽度) document.body.clientTop:' + document.body.clientTop;
		pbodyTest[4].innerText = 'boder.left(上边框的宽度) document.body.clientLeft:' + document.body.clientLeft;
		pbodyTest[5].innerText = '当前元素 上/左边框 外边缘 到 最近的已定位父级（offsetParent） 上/左边框内边缘的距离。' +
			'如果父级都没有定位，则分别是到body 顶部 和左边的距离 document.body.offsetTop:' + document.body.offsetTop;
		pbodyTest[6].innerText = '当前元素 上/左边框 外边缘 到 最近的已定位父级（offsetParent） 上/左边框内边缘的距离。' +
			'如果父级都没有定位，则分别是到body 顶部 和左边的距离 document.body.offsetLeft:' + document.body.offsetLeft;
		pbodyTest[7].innerText = '内容层顶部 到 可视区域顶部的距离 document.body.scrollTop:' + document.body.scrollTop;
		pbodyTest[8].innerText = '内容层左端 到 可视区域左端的距离. document.body.scrollLeft:' + document.body.scrollLeft;

	}
	getbodyWh();

	const eleProperty = document.getElementById('ele-property')
	for (let i = 0; i < 11; i++) {
		eleProperty.innerHTML += '<p class="p-ele-test"></p>'
	}
	const pEleTest = eleProperty.getElementsByClassName('p-ele-test')
	const eleConTest = document.getElementById('ele-con-test')
	for (let i = 0; i < 30; i++) {
		eleConTest.innerHTML += `<li>${i + 1}</li>`
	}
	function getEleConTestWh() {
		pEleTest[0].innerText = 'width + 左右padding eleConTest.clientWidth:' + eleConTest.clientWidth;
		pEleTest[1].innerText = 'width + 左右padding + 左右boder eleConTest.offsetWidth:' + eleConTest.offsetWidth;
		pEleTest[2].innerText = '获取指定标签内容层的真实宽度（可视区域宽度+被隐藏区域宽度） eleConTest.scrollWidth:' + eleConTest.scrollWidth;
		pEleTest[3].innerText = 'boder.top(上边框的宽度) eleConTest.clientTop:' + eleConTest.clientTop;
		pEleTest[4].innerText = 'boder.left(上边框的宽度) eleConTest.clientLeft:' + eleConTest.clientLeft;
		pEleTest[5].innerText = '当前元素 上/左边框 外边缘 到 最近的已定位父级（offsetParent） 上/左边框内边缘的距离。' +
			'如果父级都没有定位，则分别是到body 顶部 和左边的距离 eleConTest.offsetTop:' + eleConTest.offsetTop;
		pEleTest[6].innerText = '当前元素 上/左边框 外边缘 到 最近的已定位父级（offsetParent） 上/左边框内边缘的距离。' +
			'如果父级都没有定位，则分别是到body 顶部 和左边的距离 eleConTest.offsetLeft:' + eleConTest.offsetLeft;
		pEleTest[7].innerText = '内容层顶部 到 可视区域顶部的距离 eleConTest.scrollTop:' + eleConTest.scrollTop;
		pEleTest[8].innerText = '内容层左端 到 可视区域左端的距离. eleConTest.scrollLeft:' + eleConTest.scrollLeft;
		pEleTest[9].innerText = '内容层左端 到 可视区域左端的距离. eleConTest.style.width:' + eleConTest.style.width;
		pEleTest[10].innerText = '内容层左端 到 可视区域左端的距离. eleConTest.style.height:' + eleConTest.style.height;
	}
	getEleConTestWh();

	window.addEventListener('resize', () => {
		getWindowWh();
		getDomWh();
		getbodyWh();
		getEleConTestWh();
	})


</script>
</html>
